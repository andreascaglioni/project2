//verbosity=10;

//mesh data
 real r =5	;
 real xlow=-r,xhigh=r;
 real ylow=-r,yhigh=r;
 int res = 100;

//problem data: lambda, a from S and J; rho (measure density)
real lambda = 0.5;
real a = 1 * 1/(2*sqrt(2));	// condition a > 1/(2^(1.5))

real b11 = 1., b12 = a*lambda;
real b21 = -a, b22 = lambda;

real s11 = 1., s12 = 0;
real s21 = 0., s22 = lambda;

 real divB  = b11 + b22;
 func Bx1 = b11*x + b22*y;
 func Bx2 = b21*x + b22*y;

 func rho = exp(-0.5*(s11*x*x + (s12+s21)*x*y + s22*y*y));
 func dxrho = (-s11*x+0.5*(s12+s21)*y) * exp(-0.5*(s11*x*x + (s12+s21)*x*y + s22*y*y));
 func dyrho =  (-s22*y+0.5*(s12+s21)*x) * exp(-0.5*(s11*x*x + (s12+s21)*x*y + s22*y*y));

// eigenproblem parameters
real sigma = 0.;	//shift
int nev=10;		//number of eigenvalues to compute close to sigma

//Mesh generation
 //mesh Th=square(20,20,[pi*x,pi*y]);
 //square mesh
  int n=res, m=res;
  mesh Th=square(n,m,[xlow+(xhigh-xlow)*x,ylow+(yhigh-ylow)*y]);

fespace Vh(Th,P2);
Vh u1,u2;
varf op(u1,u2) =- int2d(Th)((dx(u1)*dx(u2)+dy(u1)*dy(u2))*rho)  
     	        - int2d(Th)((dx(u1)*dxrho+dy(u1)*dyrho)*u2)
     	      	+ int2d(Th)((Bx1*dx(u1)+Bx2*dy(u1))*u2*rho)
	      	+ int2d(Th)(divB*u1*u2*rho)			     
     	       	- int2d(Th)( sigma* u1*u2*rho )		      //OP=A_sigma B, shifted matrix
     	       	+ on(1,2,3,4,u1=0) ; 	  //BC

varf b([u1],[u2]) = int2d(Th)( u1*u2*rho );	  //no BC (!)
matrix OP= op(Vh,Vh,solver=LU,factorize=1);
matrix B= b(Vh,Vh,solver=CG,eps=1e-20);		  

real[int] ev(nev);		//to store eigenvalue
real[int] iev(nev);		//to store imaginary part of eigenvalues
Vh[int] eV(nev);		//to store eigenvectors

//resolution of dicrete eigenvalue problem
int k=EigenValue(OP,B,sym=false,sigma=sigma,value=ev,ivalue=iev, vector=eV,
		 tol=1e-10,maxit=0,ncv=0);

//print results
for (int i=0;i<k;i++){
    u1=eV[i];
    real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
    real mm= int2d(Th)(u1*u1) ;
    cout << " ---- " << i<< " "		
    	 << ev[i] << "+i" << iev[i]	//eigenvalue
    	 << " err= " << - int2d(Th)((dx(u1)*dx(u1)+dy(u1)*dy(u1))*rho)  
     	        - int2d(Th)((dx(u1)*dxrho+dy(u1)*dyrho)*u1)
     	      	+ int2d(Th)((Bx1*dx(u1)+Bx2*dy(u1))*u1*rho)
	      	+ int2d(Th)(divB*u1*u1*rho)			     
     	       	- int2d(Th)( ev[i]* u1*u1*rho )	
	<< " --- "<<endl;
    plot(eV[i],cmm= i + "th eigenvalue=" + ev[i] + "+i" + iev[i] ,wait=1, dim=3,fill=1, value=1);
}