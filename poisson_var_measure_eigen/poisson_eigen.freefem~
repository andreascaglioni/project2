verbosity=10;
//some data
func rho = exp(-0.5*(x*x+y+y));
func dxrho = -x * exp(-0.5*(x*x+y+y));
func dyrho = -y * exp(-0.5*(x*x+y+y));

//mesh
real r =5;
real x0=-r,x1=r;
real y0=-r,y1=r;
//square mesh
int res = 100;
int n=res, m=res;
mesh Th=square(n,m,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

//
fespace Vh(Th,P2);
Vh u1,u2;
real sigma = 0.;	//shift

varf op(u1,u2) = int2d(Th)((dx(u1)*dx(u2) + dy(u1)*dy(u2))*rho
     	       	 	  +(dx(u1)*dxrho + dy(u1)*dyrho)*u2 
			  - sigma* u1*u2*rho )	//OP=A-sigma*B, shifted matrix
     	       	 + on(1,2,3,4,u1=0) ; 	  //BC
varf b([u1],[u2]) = int2d(Th)( u1*u2*rho );	  //no BC (!)
matrix OP= op(Vh,Vh,solver=Crout,factorize=1); 	  //Crout solver <- op not positive
matrix B= b(Vh,Vh,solver=CG,eps=1e-20);		  
int nev=10;					//number of eigenvalues to compute close to \sigma
real[int] ev(nev);		//to store eigenvalue	
Vh[int] eV(nev);		//to sotre eigenvectors
int k=EigenValue(OP,B,sym=true,sigma=sigma,value=ev,vector=eV, tol=1e-10,maxit=0,ncv=0);
    // tol: tolerance
    //maxit: max number of iterations
    //k: number of converged eigenvalues

for (int i=0;i<k;i++){
    u1=eV[i];
    real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
    real mm= int2d(Th)(u1*u1) ;
    cout << " ---- " << i<< " " << ev[i]<< " err= "
    	 << int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) << " --- "<<endl;
    plot(eV[i],cmm="Eigen Vector "+i+" valeur =" + ev[i] ,wait=1, dim=3,fill=1, value=1);
}