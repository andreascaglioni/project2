//description: looks for eigenvalues of FP operator (with quadratic potential) in L^2(\psi^{-1})

//verbosity=1000000;

for(int i=0;i<ARGV.n;++i)
   {
     cout << ARGV[i] << endl;
   }
   
//mesh data
real r =5.5;
 real xlow=-r,xhigh=r;
 real ylow=-r,yhigh=r;
int res = 200;// atoi(ARGV[2]);

//problem data: potential V and perturbation b

// INPUT: $V, \Nabla (V), \Delta (V)$
/* real s11=1., s12=0.;
 real s21=0., s22=0.5; 
 func V = 0.5*(s11*x*x + (s12+s21)*x*y +s22*y*y);
 func dxV = +s11*x+0.5*(s12+s21)*y;
 func dyV = +s22*y+0.5*(s12+s21)*x;
 func lapV = s11 + s22;*/

//INPUT: bistable potential
 func V = 0.25*(x^2-1.)^2 + 0.5*y^2;
 func dxV = x^3 - x + 0.*y;
 func dyV = y + 0.*x ;
 func lapV = 3.*x^2 + 0.*y;

// INPUT: \rho-div-free perturbation b
real a = 0.; // atof(ARGV[2]);
func p1 = a * dyV;
func p2 = -a * dxV;
// for the quadratic potential
/*func dxb1 = a * 0.5 * (s12+s21);
  func dyb2 = -a * 0.5 * (s12+s21);*/
// for the bistable potential
func divp = 0.;

// (perturbed) drift (not to be changed)
func b1 = -dxV + p1;
func b2 = -dyV + p2;
func divb = - lapV + divp;

//invariant measere (not to be changed)
 func rho = exp(V(x,y));
 func dxrho =  rho(x,y) * dxV(x,y);
 func dyrho =  rho(x,y) * dyV(x,y);

// eigenproblem parameters
real sigma = 0.;	//shift
int nev=10;		//number of eigenvalues to compute close to sigma

//Mesh generation
 //square mesh
/*  int n=res, m=res;
  mesh Th=square(n,m,[xlow+(xhigh-xlow)*x,ylow+(yhigh-ylow)*y]);*/
  border Gamma(t=0,2*pi) { x = r *0.7* cos(t); y = r * sin(t); }
  mesh Th = buildmesh(Gamma(4*res));

fespace Vh(Th,P1);
Vh u,v;
varf op(u,v) = - int2d(Th)(dx(u)*(dx(v)*rho+v*dxrho)+dy(u)*(dy(v)*rho+v*dyrho)) // diffusion
               - int2d(Th)((b1*dx(u)+b2*dy(u))*v*rho)                           // advection 
               - int2d(Th)(divb*u*v*rho)			                // reaction
	       - int2d(Th,optimize=0)( sigma*u*v*rho )	                        // rhs
	       + on(1,2,3,4, u=0); 	                                        //homog. Dirichlet BC

varf b([u],[v]) = int2d(Th)( u*v*rho );	  //no BC (!)

matrix OP = op(Vh, Vh, solver=UMFPACK);
matrix B = b(Vh, Vh, solver=UMFPACK);		  

real[int] ev(nev);		//to store eigenvalue
real[int] iev(nev);		//to store imaginary part of eigenvalues
Vh[int] eV(nev);		//to store eigenvectors

//resolution of dicrete eigenvalue problem
int k=EigenValue(OP,B,sym=false,sigma=sigma,value=ev,ivalue=iev, vector=eV,
		 tol=1e-10,maxit=0,ncv=0);

//print results

for (int i=0;i<k;i++){
    Vh u=eV[i];
    cout << " ---- " << i+1 << " "		
    	 << ev[i] << "+i" << iev[i]	                                                 //eigenvalue
    	 << " err= " << - int2d(Th)(dx(u)*(dx(u)*rho+u*dxrho)+dy(u)*(dy(u)*rho+u*dyrho)) // diffusion
                        - int2d(Th)((b1*dx(u)+b2*dy(u))*u*rho)                           // advection 
                        - int2d(Th)(divb*u*u*rho)			                 // reaction
	                - int2d(Th)( ev[i]*u*u*rho )	                                 // rhs
	<< " --- "<<endl;
   plot(Th, eV[i],cmm= i+1 + "th eigenvalue=" + ev[i] + "+i" + iev[i] ,wait=1, dim=3,fill=1, value=1);
}


/*ofstream f("compare_eigen_perturb.out",append);
int prec = f.precision(16);
f << a << " ";
f << ev[1] << " +i " << iev[1] << endl;*/

